목차
[01. 정규화/비정규화 핵심 이론]
[02. 회원정보 등록 구현]
[03. 회원정보 조회 구현]
[04. 엔티티 회원 이름 변경 및 단위 테스트]
[05. 회원 이름 변경 내역 저장 구현]
[06. 팔로우 등록, 조회 구현]
[07. 실무에서의 정규화 비정규화에 대한 고민들]

# 01. 정규화/비정규화 핵심 이론

# 02. 회원정보 등록구현
## 회원정보 관리 규칙
- 이메일, 닉네임, 생년월일을 받아 저장한다.
- 닉네임은 10자를 초과할 수 없다.
- 회원은 닉네임을 변경할 수 있다.
	- 회원의 닉네임 변경이력을 조회 할 수 있어야한다.
## 실습
- record class (java 14 부터 preview로 등록 16부터 정식)
	- getter, setter 를 프로퍼티로 사용할 수 있도록 해준다.
	- 단순 데이터만 가지고 있으면 record class로 만들기 적합.
- 
# 03. 회원정보 조회구현
## 실습
# 04. 엔티티 회원 이름 변경 및 단위 테스트
# 05. 회원 이름 변경 내역 저장 구현
# 06. 팔로우 등록, 조회 구현
Join 쿼리로 묶으면 강 결합으로 의존성이 높아져서 유연성을 잃어버려서 아키텍쳐나 시스템이 되기 힘들다. (프로젝트 초반부터 그렇게 접근한다면 이란 문제)
조회용 데이터 베이스가 되려면 여러가지 기회 비용을 잃게 된다.

도메인간의 의존성을 낮추는 목표로 구현을 해야 한다.
# 07. 실무에서의 정규화 비정규화에 대한 고민들
중복된 데이터면 반드시 정규화를 해야하는 걸까?
- 사실 실무에서 중복 데이터면 기계정으로 정규화하는 분들이 종종 있다.
- 정규화도 비용이다. 읽기 비용을 지불하고 쓰기 비용을 줄이는것

## 정규화시 고려해야하는 것
- 얼마나 빠르게 데이터의 최신성을 보장해야 하는가?
	- 
- 히스토리성 데이터는 오히려 정규화를 하지 않아야 한다.
	- 
- 데이터 변경 주기와 조회 주기는 어떻게 되는가?
	- 데이터 변경의 주기가 조회 주기보다 빈번하다면 정규화를 하는 것이 좋다.
- 객체(테이블) 탐색 깊이가 얼마나 깊은가
	- 객체가 A -> B -> C -> D  이런 식으로 객체의 깊이가 구성되어있다면
## 정규화를 하기로 했다면 읽기시 데이터를 어떻게 가져올 것인가?
- 테이블 조인을 많이 활용하는데, 이건 사실 고민해볼 문제
	- Mysql
- 테이블 조인은 서로 다른 테이블의 결합도를 엄청나게 높인다.
- 조회시에는 성능이 좋은 별도 데이터베이스나 캐싱등 다양한 최적화 기법을 이용할 수 있다.
- 조인을 사용하게 되면, 이런 기법을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다.
- 읽기 쿼리 한번 더 발생되는 것은 그렇게 큰 부담이 아닐 수도 있다.